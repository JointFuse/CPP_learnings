/*
	Простой калькулятор

	История версий:

	Переработан Майским Александром в январе 2020г.
	Переработан Бьярне Страуструпом в мае 2007г.
	Переработан Бьярне Страуструпом в августе 2006г.
	Переработан Бьярне Страуструпом в августе 2004г.
	Разработан Бьярне Страуструпом (bs@cs.tamu.edu) весной 2004г.

	Эта программа реализует основные выражения калькулятора.
	Ввод осуществляется из потока cin; вывод - в поток cout.

	Грамматика для ввода:

	Инструкция:
		Выражение
		Добавление_переменной
		Степень_числа
		Корень_квадратный
		Помощь
		Вывод
		Выход

	Вывод:
		;

	Выход:
		quit

	Помощь:
		help

	Корень_квадратный:
		sqrt( Выражение )

	Степень_числа:
		pow( Выражение , Выражение )

	Добавление_переменной:
		# Имя_переменной = Выражение
		# const Имя_переменной = Выражение

	Имя_переменной:
		символы
		Имя_переменной '_'
		Имя_переменной цифры

	Выражение:
		Терм
		Выражение + Терм
		Выражение - Терм

	Терм:
		Первичное_выражение
		Терм * Первичное_выражение
		Терм / Первичное_выражение
		Терм % Первичное_выражение

	Первичное_выражение:
		Число
		Имя_переменной
		Имя_переменной = Выражение
		( Выражение )
		- Первичное_выражение

	Число:
		Литерал_с_плавающей_точкой

	Ввод из потока cin через Token_stream с именем ts.
	Работа с переменнымы через Symbol_stream с именем st.
*/
#ifndef Calculator_h
#define Calculator_h

#include <std_lib_facilities.h>
#include "roman_int.h"

namespace Calculator {
	//-----------------------------------------------------------------------------------

	const char let = 'L';		// Обозначение лексемы типа создания переменной
	const char quit = 'Q';		// Обозначение лексемы типа выхода из приложения
	const char print = ';';		// Обозначение лексемы типа вывода ответа
	const char number = '8';	// Обозначение лексемы типа число
	const char name = 'a';		// Обозначение лексемы типа имени переменной
	const char sqr = 'S';		// Обозначение лексемы типа корень квадратный
	const char pw = 'P';		// Обозначение лексемы типа возведение в степень
	const char cnst = 'c';		// Обозначение лексемы типа константа
	const char help = 'H';		// Обозначение лексемы типа подсказка
	const char lg = 'l';		// Обозначение лексемы типа логарифм
	const char fileread = 'r';	// Обозначение лексемы типа чтения файла
	const char filewrite = 'w';	// Обозначение лексемы типа записи файла
	const string declquit = "quit";		// Ключевое слово для выхода
	const string decllet = "#";			// Ключевое слово для инструкции let
	const string declconst = "const";	// Ключевое слово для константы
	const string declhelp = "help";		// Ключевое слово для подсказки
	const string decllog = "log";		// Ключевое слово для инструкции логарифма
	const string declfread = "from";	// Ключевое слово для чтения из файла
	const string declfwrite = "to";		// Ключевое слово для записи в файл

	const string prompt = "> ";			// Приглашение к вводу
	const string result = "= ";			// Обозначение вывода

	static ostream* my_ostream = &cout;		// Выходной поток
	static istream* my_istream = &cin;		// Входной поток
	static bool ofs_set{ false };			// 
	static bool ifs_set{ false };			// 

	//-----------------------------------------------------------------------------------

	// Лексема, имеет тип и значение (число/имя)
	class Token {
	public:
		char kind;
		double value;
		string name;

		// Инициализация для символов операций
		Token(char ch) :kind(ch), value(0) { }

		// Инициализация для чисел
		Token(char ch, double val) :kind(ch), value(val) { }

		// Инициализация для имен переменных
		Token(char ch, string n) :kind(ch), name(n) { }
	};

	//-----------------------------------------------------------------------------------

	// Поток лексем с буффером и функциями, реализующими
	// возможности получения, возврата и пропуска лексем
	class Token_stream {
	public:
		Token get();										// Считывает лексему
		void unget(Token t) { buffer = t; full = true; }	// Возвращает лексему в поток
		void ignore(char c);								// Отбрасывает символы до
															// символа с включительно

		// Инициализация пустого буфера по умолчанию
		Token_stream() :full(0), buffer(0) { }

		// Конструткор с использованием своего потока ввода вывода
		Token_stream(const istream&) :full(0), buffer(0) { }
	private:
		bool full;				// Показывает состояние буфера
		Token buffer;			// Хранит данные буфера
	};

	//-----------------------------------------------------------------------------------

	// Класс для хранения переменных
	class Variable {
	public:
		string name;
		double value;
		bool isconst;

		// Пресет инициализации переменной с модификатором константы
		Variable(string n, double v, bool b) :name(n), value(v), isconst(b) { }
	};

	//-----------------------------------------------------------------------------------

	// Класс для хранения переменных
	class Symbol_table {
	public:
		vector<Variable> names;

		double get(string s);
		void set(string s, double d);
		bool is_declared(string s);
		void define(string n, double v, bool b) { names.push_back(Variable(n, v, b)); }
	};

	//-----------------------------------------------------------------------------------

	extern double primary(Token_stream& ts);		// Обработка чисел, переменных и выражений в скобках
	extern double term(Token_stream& ts);			// Обработка действий первостепенного приоритета
	extern double expression(Token_stream& ts);		// Обработка действий второстепенной важности
	extern double declaration(Token_stream& ts);	// Обработка создания переменной
	extern double statement(Token_stream& ts);		// Поиск инструкций
	extern void clean_up_mess(Token_stream& ts);	// Очистка потока cin до знака '=' после ошибки
	extern void calculate();						// Логика работы калькулятора

	//-----------------------------------------------------------------------------------

	static Token_stream ts;
	static Symbol_table st;

	//-----------------------------------------------------------------------------------
}

#endif // !Calculator_h
