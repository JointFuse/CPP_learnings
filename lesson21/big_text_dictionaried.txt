five
popular
myth 
about
c  
bjarne
stroustrup
morgan
stanley 
columbia
university 
texas
a m
university
1 
introduction
her  
i
will
explore 
and
debunk 
five
popular
myth 
about
c   
1 
 to
understand
c   
you
must
first
learn
c 
2 
 c  
is
an
object oriented
language 
3 
 for
reliable
software 
you
need
garbage
collection 
4 
 for
efficiency 
you
must
write
low level
code 
5 
 c  
is
for
large 
complicated 
program 
only 
if
you
believe
in
any
of
these
myth  
or
have
colleagues
who
perpetuate
the  
this
short
article
is
for
you 
several
of
these
myth 
have
been
true
for
someone 
for
some
task 
at
some
time 
however 
with
today is
c   
using
widely
available
up to
date
iso
c  
2011
compiler  
and
tool  
the 
are
mere
myth  
i
deem
these
myth 
 popular 
because
i
hear
the 
often 
occasionally 
the 
are
supported
by
reason  
but
more
often
the 
are
simply
state 
as
obvious 
as
if
needing
no
support 
sometimes 
the 
are
use 
to
dismiss
c  
from
consideration
for
some
use 
each
myth
require 
a
long
paper
or
even
a
book
to
completely
debunk 
but
my
aim
her 
is
simply
to
raise
the
issues
and
to
briefly
state
my
reason  
2 
myth
1 
 to
understand
c   
you
must
first
learn
c 
no 
learning
basic
programming
using
c  
is
far
easier
than
with
c 
c
is
almost
a
subset
of
c   
but
it
is
not
the
best
subset
to
learn
first
because
c
lack 
the
notational
support 
the
type
safety 
and
the
easier to use
standard
library
offered
by
c  
to
simplify
simple
task  
consider
a
trivial
function
to
compose
an
email
address 
string
compose const
string 
name 
const
string 
domain 
 
return
name     domain 
 
it
can
be
use 
like
this
string
addr
 
compose  gre  
 research att com   
naturally 
in
a
real
program 
not
all
argument 
will
be
literal
string  
the
c
version
require 
explicit
manipulation
of
characters
and
explicit
memory
management 
char 
compose const
char 
name 
const
char 
domain 
 
char 
res
 
malloc strlen name  strlen domain  2  
  
space
for
string  
    
and
0
char 
p
 
strcpy res name  
p
  
strlen name  
 p
 
    
strcpy p 1 domain  
return
res 
 
it
can
be
use 
like
this
char 
addr
 
compose  gre   research att com   
  
   
free addr  
  
release
memory
when
done
which
version
would
you
rather
teach 
which
version
is
easier
to
use 
did
i
really
get
the
c
version
right 
are
you
sure 
why 
finally 
which
compose  
is
likely
to
be
the
most
efficient 
yes 
the
c  
version 
because
it
do  
not
have
to
count
the
argument
characters
and
do  
not
use
the
free
store
 dynamic
memory 
for
short
argument
string  
2 1
learning
c  
this
is
not
an
odd
isolated
example 
i
consider
it
typical 
so
why
do
so
many
teacher 
insist
on
the
 c
first 
approach 
 
because
that is
what
the 
have
done
for
ages 
 
because
that is
what
the
curriculum
require  
 
because
that is
the
way
the
teacher 
learned
it
in
their
youth 
 
because
c
is
smaller
than
c  
it
is
assume 
to
be
simple 
to
use 
 
because
the
students
have
to
learn
c
 or
the
c
subset
of
c   
sooner
or
later
anyway 
however 
c
is
not
the
easiest
or
most
useful
subset
of
c  
to
learn
first 
furthermore 
once
you
know
a
reasonable
amount
of
c   
the
c
subset
is
easily
learned 
learning
c
before
c  
imply  
suffering
error 
that
are
easily
avoided
in
c  
and
learning
technique 
for
mitigating
the  
for
a
modern
approach
to
teaching
c   
see
my
programming 
principles
and
practice
using
c  
 13  
it
even
has
a
chapter
at
the
end
showing
how
to
use
c 
it
has
been
use  
reasonably
successfully 
with
tens
of
thousands
of
beginning
students
in
several
university   
its
second
edition
use 
c  11
and
c  14
facility  
to
ease
learning 
with
c  11
 11 12  
c  
has
become
more
approachable
for
novices 
for
example 
her 
is
standard library
vector
initialize 
with
a
sequence
of
element  
vector int 
v
 
 1 2 3 5 8 13  
in
c  98 
we
could
only
initialize
array 
with
list  
in
c  11 
we
can
define
a
constructor
to
accept
a
  
initialize 
list
for
any
type
for
which
we
want
one 
we
could
traverse
that
vector
with
a
range for
loop 
for
 int
x
 
v 
test x  
this
will
call
test  
once
for
each
element
of
v 
a
range for
loop
can
traverse
any
sequence 
so
we
could
have
simplified
that
example
by
using
the
initialize 
list
directly 
for
 int
x
 
 1 2 3 5 8 13  
test x  
one
of
the
aim 
of
c  11
was
to
make
simple
thing 
simple 
naturally 
this
is
done
without
adding
performance
penalty   
3 
myth
2 
 c  
is
an
object oriented
language 
no 
c  
support 
oop
and
other
programming
style  
but
is
deliberately
not
limited
to
any
narrow
view
of
 object
oriented  
it
support 
a
synthesis
of
programming
technique 
including
object oriented
and
generic
programming 
more
often
than
not 
the
best
solution
to
a
problem
involf  
more
than
one
style
  paradigm   
by
 best  
i
mean
shortest 
most
comprehensible 
most
efficient 
most
maintainable 
etc 
the
 c  
is
an
oop  
myth
lead 
people
to
consider
c  
unnecessary
 when
compare 
to
c 
unless
you
need
large
class
hierarchy  
with
many
virtual
 run time
polymorphic 
function 
 
and
for
many
people
and
for
many
problem  
such
use
is
inappropriate 
believing
this
myth
lead 
other 
to
condemn
c  
for
not
being
purely
oo 
after
all 
if
you
equate
 goo  
and
 object oriented  
c  
obviously
contains
much
that
is
not
oo
and
must
therefore
be
deemed
 not
goo   
in
either
case 
this
myth
provide 
a
goo 
excuse
for
not
learning
c   
consider
an
example 
void
rotate and draw vector shape   
vs 
int
r 
 
for each vs begin   vs end   
   shape 
p 
 
p  rotate r  
   
  
rotate
all
element 
of
vs
for
 shape 
p
 
vs 
p  draw   
  
draw
all
element 
of
vs
 
is
this
object oriented 
of
course
it
is 
it
rely  
critically
on
a
class
hierarchy
with
virtual
function  
it
is
generic 
of
course
it
is 
it
rely  
critically
on
a
parameterized
container
 vector 
and
the
generic
function
for each 
is
this
functional 
sort
of 
it
use 
a
lambda
 the
  
construct  
so
what
is
it 
it
is
modern
c   
c  11 
i
use 
both
the
range for
loop
and
the
standard library
algorithm
for each
just
to
show
off
feature  
in
real
code 
i
would
have
use
only
one
loop 
which
i
could
have
written
either
way 
3 1
generic
programming
would
you
like
this
code
more
generic 
after
all 
it
work 
only
for
vector 
of
pointer 
to
shape  
how
about
list 
and
built in
array  
what
about
 smart
pointer  
 resource management
pointer   
such
as
shared ptr
and
unique ptr 
what
about
object 
that
are
not
called
shape
that
you
can
draw  
and
rotate   
consider 
template typename
iter 
void
rotate and draw iter
first 
iter
last 
int
r 
 
for each first last    auto
p 
 
p  rotate r  
   
  
rotate
all
element 
of
 first last 
for
 auto
p
 
first 
p  last 
  p 
p  draw   
  
draw
all
element 
of
 first last 
 
this
work 
for
any
sequence
you
can
iterate
through
from
first
to
last 
that is
the
style
of
the
c  
standard library
algorithm  
i
use 
auto
to
avoid
having
to
name
the
type
of
the
interface
to
 shape like
object   
that is
a
c  11
feature
meaning
 use
the
type
of
the
expression
use 
as
initialize   
so
for
the
for loop
p is
type
is
deduced
to
be
whatever
type
first
is 
the
use
of
auto
to
denote
the
argument
type
of
a
lambda
is
a
c  14
feature 
but
already
in
use 
consider 
void
use  list unique ptr shape   
lus 
container blob  
vb 
 
rotate and draw lus begin   lus end    
rotate and draw begin vb  end vb   
 
her  
i
assume
that
blob
is
some
graphical
type
with
operation 
draw  
and
rotate  
and
that
container
is
some
container
type 
the
standard library
list
 std  list 
has
member
function 
begin  
and
end  
to
help
the
use 
traverse
its
sequence
of
element  
that is
nice
and
classical
oop 
but
what
if
container
is
something
that
do  
not
support
the
c  
standard
library is
notion
of
iterating
over
a
half open
sequence 
 b e  
something
that
do  
not
have
begin  
and
end  
member  
well 
i
have
never
see 
something
container like 
that
i
could not
traverse 
so
we
can
define
free standing
begin  
and
end  
with
appropriate
semantics 
the
standard
library
provide 
that
for
c style
array  
so
if
container
is
a
c style
array 
the
problem
is
solved
 
and
c style
array 
are
still
very
common 
3 2
adaptation
consider
a
harder
case 
what
if
container
hold 
pointer 
to
object 
and
has
a
different
mode 
for
access
and
traversal 
for
example 
assume
that
you
are
supposed
to
access
a
container
like
this
for
 auto
p
 
c first   
p  nullptr 
p c next   
 
  
do
something
with
 p
   
this
style
is
not
uncommon 
we
can
map
it
to
a
 b e 
sequence
like
this
template typename
t 
struct
iter
 
t 
current 
container t  
c 
  
template typename
t 
iter t 
begin container t  
c 
 
return
iter t  c first   c  
 
template typename
t 
iter t 
end container t  
c 
 
return
iter t  nullptr c  
 
template typename
t 
iter t 
operator   iter t 
p 
 
p current
 
p c next   
return
 this 
 
template typename
t 
t 
operator  iter t 
p 
 
return
p current 
 
not 
that
this
is
modification
is
nonintrusive 
i
did
not
have
to
make
change 
to
container
or
some
container
class
hierarchy
to
map
container
int 
the
mode 
of
traversal
supported
by
the
c  
standard
library 
it
is
a
for 
of
adaptation 
rather
than
a
for 
of
refactoring 
i
chose
this
example
to
show
that
these
generic
programming
technique 
are
not
restricted
to
the
standard
library
 in
which
the 
are
pervasive  
also 
for
most
common
definition 
of
 object
oriented  
the 
are
not
object oriented 
the
idea
that
c  
code
must
be
object oriented
 meaning
use
hierarchy  
and
virtual
function 
everywhere 
can
be
seriously
damaging
to
performance 
that
view
of
oop
is
great
if
you
need
run time
resolution
of
a
set
of
type  
i
use
it
often
for
that 
however 
it
is
relatively
rigid
 not
every
related
type
fit 
int 
a
hierarchy 
and
a
virtual
function
call
inhibits
inlining
 and
that
can
cost
you
a
factor
of
50
in
speed
in
simple
and
important
case   
4
myth
3 
 for
reliable
software 
you
need
garbage
collection 
garbage
collection
do  
a
goo  
but
not
perfect 
job
at
reclaiming
unused
memory 
it
is
not
a
panacea 
memory
can
be
retained
indirectly
and
many
resource 
are
not
plain
memory 
consider 
class
filter
 
  
take
input
from
file
iname
and
produce
output
on
file
oname
pubilic 
filter const
string 
iname 
const
string 
oname  
  
constructor
 filter   
  
destructor
  
   
private 
ifstream
is 
ofstream
os 
  
   
  
this
filter is
constructor
open 
two
file  
that
done 
the
filter
performs
some
task
on
input
from
its
input
file
producing
output
on
its
output
file 
the
task
could
be
hardwired
int 
filter 
supplied
as
a
lambda 
or
provide 
as
a
function
that
could
be
provide 
by
a
derived
class
overriding
a
virtual
function 
those
detail 
are
not
important
in
a
discussion
of
resource
management 
we
can
create
filter 
like
this 
void
use   
 
filter
flt
  book    authors   
filter 
p
 
new
filter  novels   favorite    
  
use
flt
and
 p
delete
p 
 
from
a
resource
management
point
of
view 
the
problem
her 
is
how
to
guarantee
that
the
file 
are
close 
and
the
resource 
associated
with
the
two
stream 
are
properly
reclaimed
for
potential
re use 
the
conventional
solution
in
language 
and
system 
relying
on
garbage
collection
is
to
eliminate
the
delete
 which
is
easily
forgotten 
leading
to
leaks 
and
the
destructor
 because
garbage
collected
language 
rarely
have
destructor 
and
 finalizers 
are
best
avoided
because
the 
can
be
logically
tricky
and
often
damage
performance  
a
garbage
collector
can
reclaim
all
memory 
but
we
need
use 
actions
 code 
to
close
the
file 
and
to
release
any
non memory
resource 
 such
as
lock  
associated
with
the
stream  
thus
memory
is
automatically
 and
in
this
case
perfectly 
reclaimed 
but
the
management
of
other
resource 
is
manual
and
therefore
open
to
error 
and
leaks 
the
common
and
recommended
c  
approach
is
to
rely
on
destructor 
to
ensure
that
resource 
are
reclaimed 
typically 
such
resource 
are
acquired
in
a
constructor
leading
to
the
awkward
name
 resource
acquisition
is
initialization 
 raii 
for
this
simple
and
general
technique 
in
use    
the
destructor
for
flt
implicitly
call 
the
destructor 
for
the
stream 
is
and
os 
these
destructor 
in
turn
close
the
file 
and
release
the
resource 
associated
with
the
stream  
the
delete
would
do
the
same
for
 p 
experience 
users
of
modern
c  
will
have
notice 
that
use   
is
rather
clumsy
and
unnecessarily
error prone 
this
would
be
better 
void
user2  
 
filter
flt
  book    authors   
unique ptr filter 
p
 new
filter  novels   favorite     
  
use
flt
and
 p
 
now
 p
will
be
implicitly
release 
whenever
use   
is
exited 
the
programmer
cannot
forget
to
do
so 
the
unique ptr
is
a
standard library
class
designed
to
ensure
resource
release
without
runtime
or
space
overhead 
compare 
to
the
use
of
built in
 naked 
pointer  
however 
we
can
still
see
the
new 
this
solution
is
a
bit
verbose
 the
type
filter
is
repeated  
and
separating
the
construction
of
the
ordinary
pointer
 using
new 
and
the
smart
pointer
 her  
unique ptr 
inhibits
some
significant
optimization  
we
can
improve
this
by
using
a
c  14
helper
function
make unique
that
construct 
an
object
of
a
specified
type
and
return 
a
unique ptr
to
it 
void
user3  
 
filter
flt
  book    authors   
auto
p
 
make unique filter   novels   favorite    
  
use
flt
and
 p
 
unless
we
really
needed
the
second
filter
to
have
pointer
semantics
 which
is
unlikely 
this
would
be
better
still 
void
user4  
 
filter
flt
  book    authors   
filter
flt 
  novels   favorite    
  
use
flt
and
flt 
 
this
last
version
is
shorter 
simple  
clearer 
and
faster
than
the
original 
but
what
do  
filter is
destructor
do 
it
release 
the
resource 
owned
by
a
filter 
that
is 
it
close 
the
file 
 by
invoking
their
destructor   
in
fact 
that
is
done
implicitly 
so
unless
something
else
is
needed
for
filter 
we
could
eliminate
the
explicit
mention
of
the
filter
destructor
and
let
the
compile 
handle
it
all 
so 
what
i
would
have
written
was
just 
class
filter
 
  
take
input
from
file
iname
and
produce
output
on
file
oname
public 
filter const
string 
iname 
const
string 
oname  
  
   
private 
ifstream
is 
ofstream
os 
  
   
  
void
user3  
 
filter
flt
  book    authors   
filter
flt 
  novels   favorite    
  
use
flt
and
flt 
 
this
happens
to
be
simple 
than
what
you
would
write
in
most
garbage
collected
language 
 e g  
java
or
c  
and
it
is
not
open
to
leaks
caused
by
forgetful
programmer  
it
is
also
faster
than
the
obvious
alternative 
 no
spurious
use
of
the
free dynamic
store
and
no
need
to
run
a
garbage
collector  
typically 
raii
also
decreas  
the
resource
retention
time
relative
to
manual
approach   
this
is
my
idea 
for
resource
management 
it
handle 
not
just
memory 
but
general
 non memory 
resource  
such
as
file
handle  
thread
handle  
and
lock  
but
is
it
really
general 
how
about
object 
that
need 
to
be
passed
around
from
function
to
function 
what
about
object 
that
do not
have
an
obvious
single
owner 
4 1
transferring
ownership 
move
let
us
first
consider
the
problem
of
moving
object 
around
from
scope
to
scope 
the
critical
question
is
how
to
get
a
lot
of
information
out
of
a
scope
without
serious
overhead
from
copying
or
error prone
pointer
use 
the
traditional
approach
is
to
use
a
pointer 
x 
make x  
 
x 
p
 
new
x 
  
   
fill
x
   
return
p 
 
void
use   
 
x 
q
 
make x   
  
   
use
 q
   
delete
q 
 
now
who
is
responsible
for
deleting
the
object 
in
this
simple
case 
obviously
the
caller
of
make x  
is 
but
in
general
the
answer
is
not
obvious 
what
if
make x  
keep 
a
cache
of
object 
to
minimize
allocation
overhead 
what
if
use   
passed
the
pointer
to
some
other use    
the
potential
for
confusion
is
large
and
leaks
are
not
uncommon
in
this
style
of
program 
i
could
use
a
shared ptr
or
a
unique ptr
to
be
explicit
about
the
ownership
of
the
create 
object 
for
example 
unique ptr x 
make x   
but
why
use
a
pointer
 smart
or
not 
at
all 
often 
i
do not
want
a
pointer
and
often
a
pointer
would
distract
from
the
conventional
use
of
an
object 
for
example 
a
matrix
addition
function
create 
a
new
object
 the
sum 
from
two
argument  
but
returning
a
pointer
would
lead
to
seriously
odd
code 
unique ptr matrix 
operator  const
matrix 
a 
const
matrix 
b  
matrix
res
 
  a b  
that
 
is
needed
to
get
the
sum 
rather
than
a
pointer
to
it 
what
i
really
want
in
many
case 
is
an
object 
rather
than
a
pointer
to
an
object 
most
often 
i
can
easily
get
that 
in
particular 
small
object 
are
cheap
to
copy
and
i
would not
dream
of
using
a
pointer 
double
sqrt double  
  
a
square
root
function
double
s2
 
sqrt 2  
  
get
the
square
root
of
2
on
the
other
hand 
object 
holding
lot 
of
data
are
typically
handle 
to
most
of
that
data 
consider
istream 
string 
vector 
list 
and
thread 
the 
are
all
just
a
few
word 
of
data
ensuring
proper
access
to
potentially
large
amount 
of
data 
consider
again
the
matrix
addition 
what
we
want
is
matrix
operator  const
matrix 
a 
const
matrix 
b  
  
return
the
sum
of
a
and
b
matrix
r
 
x y 
we
can
easily
get
that 
matrix
operator  const
matrix 
a 
const
matrix 
b 
 
matrix
res 
  
   
fill
res
with
element
sum 
   
return
res 
 
by
default 
this
copy  
the
element 
of
res
int 
r 
but
since
res
is
just
about
to
be
destroyed
and
the
memory
holding
its
element 
is
to
be
free  
there
is
no
need
to
copy 
we
can
 steal 
the
element  
anybody
could
have
done
that
since
the
first
day 
of
c   
and
many
did 
but
it
was
tricky
to
implement
and
the
technique
was
not
widely
understood 
c  11
directly
support 
 stealing
the
representation 
from
a
handle
in
the
for 
of
move
operation 
that
transfer
ownership 
consider
a
simple
2 d
matrix
of
double  
class
matrix
 
double 
elem 
  
pointer
to
element 
int
nrow 
  
number
of
rows
int
ncol 
  
number
of
columns
public 
matrix int
nr 
int
nc 
  
constructor 
allocate
element 
 elem new
double nr nc   
nrow nr  
ncol nc 
 
for int
i 0 
i nr nc 
  i 
elem i  0 
  
initialize
element 
 
matrix const
matrix   
  
copy
constructor
matrix
operator  const
matrix   
  
copy
assignment
matrix matrix    
  
move
constructor
matrix
operator  matrix    
  
move
assignment
 matrix  
 
delete  
elem 
 
  
destructor 
free
the
element 
  
   
  
a
copy
operation
is
recognize 
by
its
reference
   
argument 
similarly 
a
move
operation
is
recognize 
by
its
rvalue
reference
    
argument 
a
move
operation
is
supposed
to
 steal 
the
representation
and
leave
an
 empty
object 
behind 
for
matrix 
that
mean 
something
like
this 
matrix  matrix matrix  
a 
  
move
constructor
 nrow a nrow  
ncol a ncol  
elem a elem 
  
 steal 
the
representation
 
a elem
 
nullptr 
  
leave
 nothing 
behind
 
that is
it 
when
the
compile 
see 
the
return
res 
it
realizes
that
res
is
soon
to
be
destroyed 
that
is 
res
will
not
be
use 
after
the
return 
therefore
it
apply  
the
move
constructor 
rather
than
the
copy
constructor
to
transfer
the
return
value 
in
particular 
for
matrix
r
 
a b 
the
res
inside
operator   
become 
empty
 
giving
the
destructor
a
trivial
task
 
and
res is
element 
are
now
owned
by
r 
we
have
managed
to
get
the
element 
of
the
result
 
potentially
megabytes
of
memory
 
out
of
the
function
 operator    
and
int 
the
caller is
variable 
we
have
done
that
at
a
minimal
cost
 probably
four
word
assignment   
expert
c  
users
have
pointed
out
that
there
are
case 
where
a
goo 
compile 
can
eliminate
the
copy
on
return
completely
 in
this
case
saving
the
four
word
move 
and
the
destructor
call  
however 
that
is
implementation
dependent 
and
i
do not
like
the
performance
of
my
basic
programming
technique 
to
depend
on
the
degree
of
cleverness
of
individual
compiler  
furthermore 
a
compile 
that
can
eliminate
the
copy 
can
as
easily
eliminate
the
move 
what
we
have
her 
is
a
simple 
reliable 
and
general
way
of
eliminating
complexity
and
cost
of
moving
a
lot
of
information
from
one
scope
to
another 
also 
move
semantics
apply  
to
assignment
also 
so
for
r
 
a b 
we
get
the
move
optimization
from
the
move
assignment
operator 
optimizing
assignment
is
far
harder
for
an
optimize 
to
do
without
language programmer
support
than
optimizing
initialization 
often 
we
do not
even
need
to
define
all
those
copy
and
move
operation  
if
a
class
is
compose 
out
of
member 
that
behave
as
desired 
we
can
simply
rely
on
the
operation 
generated
by
default 
consider 
class
matrix
 
vector double 
elem 
  
element 
int
nrow 
  
number
of
rows
int
ncol 
  
number
of
columns
public 
matrix int
nr 
int
nc 
  
constructor 
allocate
element 
 elem nr nc  
nrow nr  
ncol nc 
 
 
  
   
  
this
version
of
matrix
behave 
like
the
version
above
except
that
it
copes
slightly
better
with
error 
and
has
a
slightly
large 
representation
 a
vector
is
usually
three
word   
what
about
object 
that
are
not
handle  
if
the 
are
small 
like
an
int
or
a
complex double  
do not
worry 
otherwise 
make
the 
handle 
or
return
the 
using
 smart 
pointer  
such
as
unique ptr
and
shared ptr 
do not
mess
with
 naked 
new
and
delete
operation  
unfortunately 
a
matrix
like
the
one
i
use 
in
the
example
is
not
part
of
the
iso
c  
standard
library 
but
several
are
available
 open
source
and
commercial  
for
example 
search
the
web
for
 origin
matrix
sutton 
and
see
chapter
29
of
my
the
c  
programming
language
 fourth
edition 
 11 
for
a
discussion
of
the
design
of
such
a
matrix 
4 2
shared
ownership 
shared ptr
in
discussion 
about
garbage
collection
it
is
often
observed
that
not
every
object
has
a
unique
owner 
that
mean 
that
we
have
to
be
able
ensure
that
an
object
is
destroyed free 
when
the
last
reference
to
it
disappears 
in
the
mode 
her  
we
have
to
have
a
mechanism
to
ensure
that
an
object
is
destroyed
when
its
last
owner
is
destroyed 
that
is 
we
need
a
for 
of
shared
ownership 
say 
we
have
a
synchronized
queue 
a
sync queue 
use 
to
communicate
between
task  
a
produce 
and
a
consumer
are
each
give 
a
pointer
to
the
sync queue 
void
startup  
 
sync queue 
p
 
new
sync queue 200  
  
trouble
ahead 
thread
t1
 task  iqueue p  
  
task 
read 
from
 iqueue
and
write 
to
 p
thread
t2
 task  p oqueue  
  
task 
read 
from
 p
and
write 
to
 oqueue
t1 detach   
t2 detach   
 
i
assume
that
task  
task  
iqueue 
and
oqueue
have
been
suitably
define 
elsewhere
and
apologize
for
letting
the
thread
outlive
the
scope
in
which
the 
were
create 
 using
detatch    
also 
you
may
imagine
pipelines
with
many
more
task 
and
sync queue  
however 
her 
i
am
only
interested
in
one
question 
 who
delete 
the
sync queue
create 
in
startup    
as
written 
there
is
only
one
goo 
answer 
 whoever
is
the
last
to
use
the
sync queue  
this
is
a
classic
motivating
case
for
garbage
collection 
the
original
for 
of
garbage
collection
was
counted
pointer  
maintain
a
use
count
for
the
object
and
when
the
count
is
about
to
go
to
zero
delete
the
object 
many
language 
today
rely
on
a
variant
of
this
idea
and
c  11
support 
it
in
the
for 
of
shared ptr 
the
example
become  
void
startup  
 
auto
p
 
make shared sync queue  200  
  
make
a
sync queue
and
return
a
stared ptr
to
it
thread
t1
 task  iqueue p  
  
task 
read 
from
 iqueue
and
write 
to
 p
thread
t2
 task  p oqueue  
  
task 
read 
from
 p
and
write 
to
 oqueue
t1 detach   
t2 detach   
 
now
the
destructor 
for
task 
and
task 
can
destroy
their
shared ptr 
 and
will
do
so
implicitly
in
most
goo 
design  
and
the
last
task
to
do
so
will
destroy
the
sync queue 
this
is
simple
and
reasonably
efficient 
it
do  
not
imply
a
complicated
run time
system
with
a
garbage
collector 
importantly 
it
do  
not
just
reclaim
the
memory
associated
with
the
sync queue 
it
reclaim 
the
synchronization
object
 mutex 
lock 
or
whatever 
embedded
in
the
sync queue
to
mange
the
synchronization
of
the
two
thread 
running
the
two
task  
what
we
have
her 
is
again
not
just
memory
management 
it
is
general
resource
management 
that
 hidden 
synchronization
object
is
handle 
exactly
as
the
file
handle 
and
stream
buffer 
were
handle 
in
the
earlier
example 
we
could
try
to
eliminate
the
use
of
shared ptr
by
introducing
a
unique
owner
in
some
scope
that
enclos  
the
task  
but
doing
so
is
not
always
simple 
so
c  11
provide 
both
unique ptr
 for
unique
ownership 
and
shared ptr
 for
shared
ownership  
4 3
type
safety
her  
i
have
only
addressed
garbage
collection
in
connection
with
resource
management 
it
also
has
a
role
to
play
in
type
safety 
as
long
as
we
have
an
explicit
delete
operation 
it
can
be
misused 
for
example 
x 
p
 
new
x 
x 
q
 
p 
delete
p 
  
   
q  do something   
  
the
memory
that
held
 p
may
have
been
re use 
do not
do
that 
naked
delete 
are
dangerous
 
and
unnecessary
in
general use 
code 
leave
delete 
inside
resource
management
class   
such
as
string 
ostream 
thread 
unique ptr 
and
shared ptr 
there 
delete 
are
carefully
matched
with
new 
and
harmless 
4 4
summary 
resource
management
ideals
for
resource
management 
i
consider
garbage
collection
a
last
choice 
rather
than
 the
solution 
or
an
idea  
1 
use
appropriate
abstraction 
that
recursively
and
implicitly
handle
their
own
resource  
prefer
such
object 
to
be
scope 
variable  
2 
when
you
need
pointer reference
semantics 
use
 smart
pointer  
such
as
unique ptr
and
shared ptr
to
represent
ownership 
3 
if
everything
else
fails
 e g  
because
you 
code
is
part
of
a
program
using
a
mess
of
pointer 
without
a
language
supported
strategy
for
resource
management
and
error
handling  
try
to
handle
non memory
resource 
 by
hand 
and
plug
in
a
conservative
garbage
collector
to
handle
the
almost
inevitable
memory
leaks 
is
this
strategy
perfect 
no 
but
it
is
general
and
simple 
traditional
garbage collection
base 
strategy  
are
not
perfect
either 
and
the 
do not
directly
address
non memory
resource  
5 
myth
4 
 for
efficiency 
you
must
write
low level
code 
many
people
see 
to
believe
that
efficient
code
must
be
low
level 
some
even
see 
to
believe
that
low level
code
is
inherently
efficient
  if
it is
that
ugly 
it
must
be
fast 
someone
must
have
spent
a
lot
of
time
and
ingenuity
to
write
that    
you
can 
of
course 
write
efficient
code
using
low level
facility  
only 
and
some
code
has
to
be
low level
to
deal
directly
with
machine
resource  
however 
do
measure
to
see
if
you 
effort 
were
worthwhile 
modern
c  
compiler 
are
very
effective
and
modern
machine
architectures
are
very
tricky 
if
needed 
such
low level
code
is
typically
best
hidden
behind
an
interface
designed
to
allow
more
convenient
use 
often 
hiding
the
low
level
code
behind
a
higher level
interface
also
enables
better
optimization 
 e g  
by
insulating
the
low level
code
from
 insane 
use   
where
efficiency
matters 
first
try
to
achieve
it
by
expressing
the
desired
solution
at
a
high
level 
do not
dash
for
bit 
and
pointer  
5 1
c is
qsort  
consider
a
simple
example 
if
you
want
to
sort
a
set
of
floating point
number 
in
decreasing
order 
you
could
write
a
piece
of
code
to
do
so 
however 
unless
you
have
extreme
requirements
 e g  
have
more
number 
than
would
fit
in
memory  
doing
so
would
be
most
naive 
for
decades 
we
have
had
library
sort
algorithm 
with
acceptable
performance
characteristics 
my
least
favorite
is
the
iso
standard
c
library
qsort   
int
greater const
void 
p 
const
void 
q 
  
three way
compare
 
double
x
 
  double  p 
  
get
the
double
value
store 
at
the
address
p
double
y
 
  double  q 
if
 x y 
return
1 
if
 x y 
return
 1 
return
0 
 
void
do my sort double 
p 
unsigned
int
n 
 
qsort p n sizeof  p  greater  
 
int
main  
 
double
a 500000  
  
   
fill
a
   
do my sort a sizeof a  sizeof  a   
  
pass
pointer
and
number
of
element 
  
   
 
if
you
are
not
a
c
programmer
or
if
you
have
not
use 
qsort
recently 
this
may
require
some
explanation 
qsort
take 
four
argument 
 
a
pointer
to
a
sequence
of
byte 
 
the
number
of
element 
 
the
size
of
an
element
store 
in
those
byte 
 
a
function
comparing
two
element 
passed
as
pointer 
to
their
first
byte 
not 
that
this
interface
throw 
away
information 
we
are
not
really
sorting
byte  
we
are
sorting
double  
but
qsort
do   not
know
that
so
that
we
have
to
supply
information
about
how
to
compare
double 
and
the
number
of
byte 
use 
to
hold
a
double 
of
course 
the
compile 
already
know 
such
information
perfectly
well 
however 
qsort is
low level
interface
prevents
the
compile 
from
taking
advantage
of
type
information 
having
to
state
simple
information
explicitly
is
also
an
opportunity
for
error  
did
i
swap
qsort   s
two
integer
argument  
if
i
did 
the
compile 
would not
notice 
did
my
compare  
follow
the
conventions
for
a
c
three way
compare 
if
you
look
at
an
industrial
strength
implementation
of
qsort
 please
do  
you
will
notice
that
it
work 
hard
to
compensate
for
the
lack
of
information 
for
example 
swapping
element 
expressed
as
a
number
of
byte 
take 
work
to
do
as
efficiently
as
a
swap
of
a
pair
of
double  
the
expensive
indirect
call 
to
the
comparison
function
can
only
be
eliminate 
if
the
compile 
do  
constant
propagation
for
pointer 
to
function  
5 2
c   s
sort  
compare
qsort  
to
its
c  
equivalent 
sort   
void
do my sort vector double  
v 
 
sort v    double
x 
double
y 
 
return
x y 
   
  
sort
v
in
decreasing
order
 
int
main  
 
vector double 
vd 
  
   
fill
vd
   
do my sort v  
  
   
 
less
explanation
is
needed
her  
a
vector
know 
its
size 
so
we
do not
have
to
explicitly
pass
the
number
of
element  
we
never
 lose 
the
type
of
element  
so
we
do not
have
to
deal
with
element
size  
by
default 
sort  
sort 
in
increasing
order 
so
i
have
to
specify
the
comparison
criteria 
just
as
i
did
for
qsort   
her  
i
passed
it
as
a
lambda
expression
comparing
two
double 
using
  
as
it
happens 
that
lambda
is
trivially
inline 
by
all
c  
compiler 
i
know
of 
so
the
comparison
really
become 
just
a
greater than
machine
operation 
there
is
no
 inefficient 
indirect
function
call 
i
use 
a
container
version
of
sort  
to
avoid
being
explicit
about
the
iterators 
that
is 
to
avoid
having
to
write 
std  sort v begin   v end      double
x 
double
y 
 
return
x y 
   
i
could
go
further
and
use
a
c  14
comparison
object 
sort v greater      
  
sort
v
in
decreasing
order
which
version
is
faster 
you
can
compile
the
qsort
version
as
c
or
c  
without
any
performance
difference 
so
this
is
really
a
comparison
of
programming
style  
rather
than
of
language  
the
library
implementation 
see 
always
to
use
the
same
algorithm
for
sort
and
qsort 
so
it
is
a
comparison
of
programming
style  
rather
than
of
different
algorithm  
different
compiler 
and
library
implementation 
give
different
result  
of
course 
but
for
each
implementation
we
have
a
reasonable
reflection
of
the
effect 
of
different
level 
of
abstraction 
i
recently
ran
the
example 
and
found
the
sort  
version
2 5
time 
faster
than
the
qsort  
version 
you 
mileage
will
vary
from
compile 
to
compile 
and
from
machine
to
machine 
but
i
have
never
see 
qsort
beat
sort 
i
have
see 
sort
run
10
time 
faster
than
qsort 
how
com  
the
c  
standard library
sort
is
clearly
at
a
higher
level
than
qsort
as
well
as
more
general
and
flexible 
it
is
type
safe
and
parameterized
over
the
storage
type 
element
type 
and
sorting
criteria 
there
is not
a
pointer 
cast 
size 
or
a
byte
in
sight 
the
c  
standard
library
stl 
of
which
sort
is
a
part 
try  
very
hard
not
to
throw
away
information 
this
make 
for
excellent
inlining
and
goo 
optimization  
generality
and
high level
code
can
beat
low level
code 
it
do   not
always 
of
course 
but
the
sort qsort
comparison
is
not
an
isolated
example 
always
start
out
with
a
higher level 
precise 
and
type
safe
version
of
the
solution 
optimize
 only 
if
needed 
6 
myth
5 
 c  
is
for
large 
complicated 
program 
only 
c  
is
a
big
language 
the
size
of
its
definition
is
very
similar
to
those
of
c 
and
java 
but
that
do  
not
imply
that
you
have
to
know
every
detail
to
use
it
or
use
every
feature
directly
in
every
program 
consider
an
example
using
only
foundational
components
from
the
standard
library 
set string 
get address   istream 
is 
 
set string 
addr 
regex
pat
 
r    w       w       w       w        
  
email
address
pattern
smatch
m 
for
 string
s 
getline is s  
 
  
read
a
line
if
 regex search s 
m 
pat  
  
look
for
the
pattern
addr insert m 0   
  
save
address
in
set
return
addr 
 
i
assume
you
know
regular
expression  
if
not 
now
may
be
a
goo 
time
to
read
up
on
the  
not 
that
i
rely
on
move
semantics
to
simply
and
efficiently
return
a
potentially
large
set
of
string  
all
standard library
container 
provide
move
constructor  
so
there
is
no
need
to
mess
around
with
new 
for
this
to
work 
i
need
to
include
the
appropriate
standard
library
components 
 include string 
 include set 
 include iostream 
 include sstream 
 include regex 
using
namespace
std 
let is
test
it 
istringstream
test
 
  
a
stream
initialize 
to
a
sting
containing
some
address  
 asasasa n 
 bs foo com n 
 ms foo bar com aaa n 
 ms foo bar com
aaa n 
 asdf
bs ms x n 
   bs ms x  goo n 
 cft
foo bar ff ss tt vv yy
asas 
 qwert n 
  
int
main  
 
auto
addr
 
get address   test  
  
get
the
email
address  
for
 auto 
s
 
addr 
  
write
out
the
address  
cout
  
s
  
  n  
 
this
is
just
an
example 
it
is
easy
to
modify
get address    
to
take
the
regex
pattern
as
an
argument 
so
that
it
could
find
url 
or
whatever 
it
is
easy
to
modify
get address    
to
recognize
more
than
one
occurrence
of
a
pattern
in
a
line 
after
all 
c  
is
designed
for
flexibility
and
generality 
but
not
every
program
has
to
be
a
complete
library
or
application
framework 
however 
the
point
her 
is
that
the
task
of
extracting
email
address  
from
a
stream
is
simply
expressed
and
easily
tested 
6 1
library  
in
any
language 
writing
a
program
using
only
the
built in
language
feature 
 such
as
if 
for 
and
  
is
quite
tedious 
conversely 
give 
suitable
library  
 such
as
graphics 
route
planning 
and
database 
just
about
any
task
can
be
accomplished
with
a
reasonable
amount
of
effort 
the
iso
c  
standard
library
is
relatively
small
 compare 
to
commercial
library    
but
there
are
plenty
of
open source
and
commercial
library  
 out
there  
for
example 
using
 open
source
or
proprietary 
library   
such
as
boost
 3  
poco
 2  
amp
 4  
tbb
 5  
cinder
 6  
vxwidgets
 7  
and
cgal
 8  
many
common
and
more specialized
task 
become
simple 
as
an
example 
let is
modify
the
program
above
to
read
url 
from
a
web
page 
first 
we
generalize
get address    
to
find
any
string
that
match  
a
pattern 
set string 
get string  istream 
is 
regex
pat 
 
set string 
res 
smatch
m 
for
 string
s 
getline is s  
 
  
read
a
line
if
 regex search s 
m 
pat  
res insert m 0   
  
save
match
in
set
return
res 
 
that
is
just
a
simplification 
next 
we
have
to
figure
out
how
to
go
out
onto
the
web
to
read
a
file 
boost
has
a
library 
asio 
for
communicating
over
the
web 
 include
 boost asio hpp 
  
get
boost asio
talking
to
a
web
serve 
is
a
bit
involved 
int
main  
try
 
string
serve 
 
 www stroustrup com  
boost  asio  ip  tcp  iostream
s
 serve   http   
  
make
a
connection
connect to file s serve   c   html   
  
check
and
open
file
regex
pat
 r   http     www          w       
  
url
for
 auto
x
 
get string  s pat  
  
look
for
url 
cout
  
x
  
  n  
 
catch
 std  exception 
e 
 
std  cout
  
 exception 
 
  
e what  
  
  n  
return
1 
 
looking
in
www stroustrup com s
file
c   html 
this
gave 
http   www h eng cam ac uk help tpl language  c   html
http   www accu org
http   www artima co cppsource
http   www boost org
   
i
use 
a
set 
so
the
url 
are
printed
in
lexicographical
order 
i
sneakily 
but
not
altogether
unrealistically 
 hid 
the
checking
and
http
connection
management
in
a
function
 connect to file    
void
connect to file iostream 
s 
const
string 
serve  
const
string 
file 
  
open
a
connection
to
serve 
and
open
an
attach
file
to
s
  
skip
header 
 
if
  s 
throw
runtime error  can t
connect n   
  
request
to
read
the
file
from
the
serve  
s
  
 get
 
  
 http     serve      file
  
 
http 1 0 r n  
s
  
 host 
 
  
serve 
  
  r n  
s
  
 accept 
    r n  
s
  
 connection 
close r n r n  
  
check
that
the
response
is
ok 
string
http version 
unsigned
int
status code 
s
  
http version
  
status code 
string
status message 
getline s status message  
if
  s
  
http version substr 0 
5 
  
 http   
throw
runtime error 
 invalid
response n 
  
if
 status code  200 
throw
runtime error 
 response
returned
with
status
code 
  
  
discard
the
response
header  
which
are
terminated
by
a
blank
line 
string
header 
while
 getline s header 
  
header    r  
 
 
as
is
most
common 
i
did
not
start
from
scratch 
the
http
connection
management
was
mostly
copied
from
christopher
kohlhoff is
asio
documentation
 9  
6 2
hello 
world 
c  
is
a
compile 
language
designed
with
the
primary
aim
of
delivering
goo  
maintainable
code
where
performance
and
reliability
matters
 e g  
infrastructure
 10   
it
is
not
mean 
to
directly
compete
with
interpreted
or
minimally compile 
 scripting 
language 
for
really
tiny
program  
indeed 
such
language 
 e g 
javascript 
 
and
other 
 e g  
java 
 
are
often
implemented
in
c   
however 
there
are
many
useful
c  
program 
that
are
just
a
few
dozen
or
a
few
hundred
line 
long 
the
c  
library
writers
could
help
her  
instead
of
 just 
focusing
on
the
clever
and
advanced
part 
of
a
library 
provide
easy to try
 hello 
world 
example  
have
a
trivial to install
minimal
version
of
the
library
and
have
a
max one page
 hello 
world  
example
of
what
the
library
can
do 
we
are
all
novices
at
some
time
or
other 
incidentally 
my
version
of
 hello 
world  
for
c  
is 
 include iostream 
int
main  
 
std  cout
  
 hello 
world n  
 
i
find
longer
and
more
complicated
version 
less
than
amusing
when
use 
to
illustrate
iso
c  
and
its
standard
library 
7
the
many
use 
of
myth 
myth 
sometimes
have
a
basis
in
reality 
for
each
of
these
myth 
there
have
been
time 
and
situations
where
someone
could
reasonably
believe
the 
base 
on
evidence 
for
today 
i
consider
the 
flat out
wrong 
simple
misunderstandings 
however
honestly
acquired 
one
problem
is
that
myth 
always
serve
a
purpose
 
or
the 
would
have
died
out 
these
five
myth 
have
serve 
and
serve
in
a
variety
of
role  
 
the 
can
offer
comfort 
no
change
is
needed 
no
reevaluation
of
assumptions
is
needed 
what
is
familiar
feels
goo  
change
can
be
unsettling 
so
it
would
be
nice
if
the
new
was
not
viable 
 
the 
can
save
time
getting
started
with
a
new
project 
if
you
 think
you 
know
what
c  
is 
you
do not
have
to
spend
time
learning
something
new 
you
do not
have
to
experiment
with
new
technique  
you
do not
have
to
measure
for
potential
performance
snags 
you
do not
have
to
train
new
programmer  
 
the 
can
save
you
from
having
to
learn
c   
if
those
myth 
were
true 
why
on
earth
would
you
want
to
spend
time
learning
c   
 
the 
can
help
promote
alternative
language 
and
technique  
if
those
myth 
were
true 
alternative 
are
obviously
necessary 
but
these
myth 
are
not
true 
so
intellectually
honest
promotion
of
status
quo 
alternative 
to
c   
or
avoidance
of
modern
c  
programming
style 
cannot
rely
on
the  
cruising
along
with
an
older
view
of
c  
 with
familiar
language
subset 
and
technique  
may
be
comfortable 
but
the
state
of
software
is
such
that
change
is
necessary 
we
can
do
much
better
than
with
c 
 c
with
class    
c  98 
etc 
sticking
to
the
old and true
is
not
cost
free 
maintenance
cost
is
often
higher
than
for
more
modern
code 
older
compiler 
and
tool
chain 
deliver
less
performance
and
worse
analysis
than
modern
tool 
relying
on
more
structured
modern
code 
goo 
programmer 
often
choose
not
to
work
on
 antique 
code 
modern
c  
 c  11 
c  14 
and
the
programming
technique 
it
support 
are
different
and
far
better
than
 common 
popular
myth  
would
indicate 
if
you
believe
one
of
these
myth  
do not
just
take
my
word
for
it
being
false 
try
it 
test
it 
measure
 the
old
way 
and
the
alternative 
for
some
problem
you
care
about 
try
to
get
a
real
hold
on
the
time
needed
to
learn
the
new
facility  
and
technique  
the
time
to
write
code
the
new
way 
the
runtime
of
the
modern
code 
do not
forget
to
compare
the
likely
maintenance
cost
to
the
cost
of
sticking
with
 the
old
way  
the
only
perfect
debunking
of
a
myth
is
to
present
evidence 
her  
i
have
presented
only
example 
and
argument  
and
no 
this
is
not
an
argument
that
c  
is
perfect 
c  
is
not
perfect 
it
is
not
the
best
language
for
everything
and
for
everybody 
neither
is
any
other
language 
take
c  
for
what
it
is 
rather
than
what
it
was
20
year 
ago
or
what
someone
promoting
an
alternative
claims
it
to
be 
to
make
a
rational
choice 
get
some
solid
information
and
 
as
far
as
time
allow 
 
try
for
yourself
to
see
how
current
c  
work 
for
the
kind
of
problem 
you
face 
8
summary
do not
believe
 common
knowledge 
about
c  
or
its
use
without
evidence 
this
article
take 
on
five
frequently
expressed
opinions
about
c  
and
argues
that
the 
are
 mere
myth   
1 
 to
understand
c   
you
must
first
learn
c 
2 
 c  
is
an
object oriented
language 
3 
 for
reliable
software 
you
need
garbage
collection 
4 
 for
efficiency 
you
must
write
low level
code 
5 
 c  
is
for
large 
complicated 
program 
only 
the 
do
harm 
9
feedback
not
convinced 
tell
me
why 
what
other
myth 
have
you
encountered 
why
are
the 
myth 
rather
than
valid
experience  
what
evidence
do
you
have
that
might
debunk
a
myth 
10
reference 
1 
iso iec
14882 2011
programming
language
c  
2 
poco
library   
http   pocoproject org 
3 
boost
library   
http   www boost org 
4 
amp 
c  
accelerated
massive
parallelism 
http   msdn microsoft com en us library hh265137 aspx
5 
tbb 
intel
threading
building
blocks 
www threadingbuildingblocks org 
6 
cinder 
a
library
for
professional quality
creative
coding 
http   libcinder org 
7 
vxwidgets 
a
cross platform
gui
library 
www wxwidgets org
8 
cgal
 
computational
geometry
algorithm 
library 
www cgal org
9 
christopher
kohlhoff 
boost asio
documentation 
http   www boost org do  libs 1 55 0 do  html boost asio html
10 
b 
stroustrup 
software
development
for
infrastructure 
computer 
vol 
45 
no 
1 
pp 
47 58 
jan 
2012 
do  10 1109 mc 2011 353 
11 
bjarne
stroustrup 
the
c  
programming
language
 4th
edition  
addison wesley 
isbn
978 0321563842 
may
2013 
12 
bjarne
stroustrup 
a
tour
of
c   
addison
wesley 
isbn
978 0321958310 
september
2013 
13 
b 
stroustrup 
programming 
principles
and
practice
using
c  
 2nd
edition  
addison wesley 
isbn
978 0321992789 
may
2014 
postscript
the
10
sections
of
this
article
was
posted
on
isocpp org
in
three
installments
and
reposted
widely 
it
attracted
a
quite
varied
set
of
comments 
i
have
now
fixed
a
few
typos
that
were
reported 
thanks 
this
postscript
is
my
observations
on
some
of
the
comments
posted 
the
comments
prove
 
yet
again
 
that
the
 myth  
paper
was
needed 
people
keep
repeating
the
old
hairy
rationalizations 
unfortunately 
many
programmer 
do not
read
long
paper 
and
dismiss
short
one 
for
being
incomplete 
the
unwillingness
of
many
programmer 
to
read
a
long
paper
was
the
reason
i
release 
this
paper
in
three
separate
part  
this
paper
is
not
a
research
paper
carefully
outlining
every
alternative
and
carefully
documenting
every
detail 
i
said
that
right
up
front 
each
myth
require 
a
long
paper
or
even
a
book
to
completely
debunk 
but
my
aim
her 
is
simply
to
raise
the
issues
and
to
briefly
state
my
reason  
however 
many
seems
to
confuse
the
example 
use 
to
illustrate
a
point
with
the
point
itself 
many
tried
to
 debunk
the
debunking 
by
changing
example  
by
changing
the
constraints
on
the
example  
or
by
deeming
the
example 
trivial 
the
example 
are
small
 
the 
have
to
be
to
fit
int 
a
short
paper
 
but
the 
are
not
unrepresentative
of
code
found
as
part
of
real world
program  
many
commenters
quickly
did
a
shift
from
the
c  11 c  14
that
i
base
my
argument 
on
to
some
older
version 
c  14
is
not
the
c  
of
the
1980s 
it
is
not
what
most
people
were
first
taught 
it
is
not
the
c  
that
people
is
presented
with
in
most
beginning
c  
course 
today 
it
is
not
what
most
people
see
when
the 
look
at
a
large
code
base 
i
want
to
change
that 
not
being
able
to
do
some
example
that
i
present
in
an
antique
version
of
c  
or
with
an
outdated
compile 
is
unfortunate 
but
better
version 
of
the
major
compile 
ship
 typically
for
free 
today 
i
showed
no
example 
of
 bleeding
edge 
code 
the
problem
of
code
in
older
style 
is
one
that
every
successful
programming
language
must
face 
so
please
do not
judge
c  
exclusively
base 
on
20 year old
technique 
and
10 year
old
compiler  
look
at
modern
c  
and
find
way 
of
getting
it
int 
use
 
many
has
already 
you
almost
certainly
use 
a
program
today
that
was
written
using
c  11 
there
are
c  11
in
many
steps
of
the
chain
between
the
computer
on
which
i
write
this
and
the
computer
on
which
you
read
it 
quite
a
few
comments
were
along
the
line 
of
 language
x
has
a
feature
that
do  
exactly
that 
and
 library
y
in
language
x
do  
exactly
that  
obviously 
if
you
have
a
language
that
provide 
a
simple 
solution
to
the
best
you
can
do
in
c   
with
acceptable
performance 
portability 
and
tool chain
constraints
for
what
you
want
to
do 
use
it 
however 
no
language
and
library
is
perfect
for
everything
and
everybody 
i
present
example 
of
general
problem 
and
general
technique  
matching
a
single
example
in
some
way
is
not
necessarily
significant 
my
point 
are
general
and
the
example 
only
simple
illustrations 
give 
a
sufficiently
goo 
library 
just
about
any
programming
task
can
be
simple
and
pleasant 
give 
a
sufficiently
constrained
task 
we
can
always
design
a
specialized
language
to
be
more
elegant
than
a
general purpose
one 
for
example 
the
asio
library
i
use 
in
6 1
is
a
flexible 
efficient 
general purpose
networking
library 
for
any
one
task 
i
could
wrap
it
in
a
far
simple 
function
 or
small
set
of
function  
to
make
that
task
significantly
more
convenient 
the
code
i
showed
would
the 
be
the
implementation 
my
key
point
in
6 2
is
that
the
c  
library
development
community
could
do
many
programmer 
a
favor
by
spending
a
little
more
tome
making
simple
thing 
simple 
for
example
99 
of
the
time
i
prefer
sort v 
to
sort v begin   v end    
performance
my
comments
about
performance
caused
quite
a
stir
in
place  
many
people
tried
to
dismiss
the 
with
argument 
or
mere
counter assertions 
i
do not
accept
performance
argument 
unsupported
by
measurements 
my
comments
have
been
validated
by
real
performance
measure 
in
many
contexts
over
year  
many
can
be
found
in
the
literature 
my
main
performance
point 
hold
over
a
wide
range
of
similar
example 
and
scale 
please
not 
that
i
assume
a
modern 
standard  conforming
c  
implementation 
for
example 
when
i
talk
about
the
performance
of
the
short string
optimization 
i
do not
mean
a
pre c  11
standard
library
without
that
optimization 
also 
i
take
no
notice
of
comments
to
the
effect
that
c  
facility  
such
as
std  sort  
or
std  string
are
slow
if
you
do not
use
an
optimize 
 
of
course
the 
are 
but
talking
about
performance
of
unoptimized
code
is
silly 
if
you
use
gcc
or
clang
use
 o2 
for
microsoft 
use
release
mode 
c
i
know
c
and
its
standard
library
pretty
well 
i
wrote
considerable
amount 
of
c
before
many
of
today is
students
were
even
born
and
contributed
significantly
to
the
c
language 
function
prototypes 
const 
inline 
declarations
in
for statement 
declarations
as
statement  
and
more
cam 
from
my
work 
i
have
followed
its
development
and
the
evolution
programming
style 
in
c 
yes 
the
c
version 
of
compose  
fails
to
check
malloc   s
return
value 
i
did
ask
if
you
though 
i
got
it
right 
i
did
not
present
production quality
code 
and
i
knew
that 
failing
to
check
result 
is
a
major
source
of
error  
so
my
 mistake 
failing
to
check
the
result
of
malloc  
was
deliberate
illustrate 
a
real
problem 
as
in
this
case 
exception 
can
often
help 
yes 
you
could
write
the
c
version
of
compose  
differently
using
less
well
know 
standard library
function  
and
yes 
you
can
avoid
the
use
of
free
store
if
you
let
the
caller
supply
a
buffer
allocate 
on
the
stack
and
let
the
caller
deal
with
the
problem
of
string
argument 
that
would
overflow
the
buffer 
however 
such
alternative 
completely
miss
the
point 
it
is
harder
to
write
such
code
than
the
c  
version 
and
far
harder
to
get
it
right 
novices
get
the
c  
version
right
the
first
time 
but
not
any
of
the
c
version  
especially
not
the
c
version 
that
rely
on
standard library
function
not
commonly
taught
to
novices 
c  
use
c  
has
been
use 
for
demanding
embedded
system 
and
critical
system 
for
year  
example 
are
the
mars
rovers
 scene
analysis
and
autonomous
operation   
the
f 35s
and
f 16s
 flight
controls  
and
many 
many
more 
http   www stroustrup com application  html 
and 
yes 
the
orion
space
capsule
is
programmed
in
c   
library  
yes 
library  
vary
in
quality
and
it
can
be
extremely
hard
to
choose
from
the
large
selection
of
library  
beyond
the
standard 
this
is
a
major
problem 
however 
such
library  
exist
and
researching
the 
is
often
more
productive
than
simply
barging
ahead
and
reinventing
yet another
wheel 
unfortunately 
c  
library  
are
often
not
designed
for
interoperability
with
other
library   
unfortunately 
there
is
not
a
single
place
to
go
to
look
for
c  
library   
teaching
i
have
observed
students
being
taught
by
the
 c
first 
approach
for
many
year 
and
see 
the
program 
written
by
such
students
for
decades 
i
have
taught
c  
as
the
first
programming
language
to
thousands
of
students
over
several
year  
my
claims
about
the
teachability
of
c  
are
base 
on
significant
experience 
rather
than
introspection 
c  
is
easier
to
teach
to
beginner 
than
c
because
of
a
better
type
system
and
more
notational
support 
there
are
also
fewer
tricks
and
workarounds
to
learn 
just
imagine
how
you
would
teach
the
style 
of
programming
you
use
in
c
using
c   
c   s
support
for
those
is
better 
i
would
never
dream
of
giving
a
beginner is
c  
course
that
 
did not
include
a
thorough
grounding
in
memory
management 
pointer  
etc 
 
did not
give
the
students
a
look
at
 plain
c  
and
some
idea
of
how
to
use
it
 
did not
present
a
rational 
for
the
major
feature 
 
tried
to
teach
all
of
c  
and
every
c  
technique
similarly 
goo 
c
teacher 
do
not
try
to
teach
all
of
c
and
all
c
technique 
to
beginner  
http   www stroustrup com programming html
is
my
answer
to
the
question
 how
would
you
teach
c  
to
beginner   
it
work  
for
a
rather
old
paper
comparing
aspects
of
teachability
of
c
and
c   
see
b 
stroustrup 
learning
standard
c  
as
a
new
language 
c c  
users
journal 
pp
43 54 
may
1999
 www stroustrup com paper  html  
today 
i
could
write
the
c
version
a
bit
better
and
the
c  
version
quite
a
bit
better 
the
example 
reflect
common
style 
of
the
time
 and
were
reviewed
by
expert
c
and
c  
programmer   
c  
today
is
iso
standard
c  14 
rather
than
what
i
described
30
year 
ago
or
what
you 
teacher
may
have
taught
you
20
year 
ago 
learn
c  11 c  14
as
supported
by
current
mainstream
compiler 
and
get
use 
to
it 
it
is
a
far
better
tool
than
earlier
version 
of
c   
similarly 
c
today
is
iso
standard
c11 
rather
than
k r
c
 though
i
am
not
sure
if
the
c
compiler 
today
are
as
close
to
c11
as
the
c  
compiler 
are
close
to
c  14  
i
am
appalled
by
much
that
is
taught
as
 goo 
c    
c  
is
not
 and
never
were
mean 
to
be 
an
 oop 
language 
it
is
a
language
that
support 
oop 
other
programming
technique  
and
combinations
of
such
technique  
if
you
are
an
experience 
programmer 
i
recommend
a
tour
of
c  
 12 
as
a
quick
overview
of
modern
c   
23
